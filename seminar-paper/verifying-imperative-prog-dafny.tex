\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
% package for including graphics with figure-environment
\usepackage{graphicx}
% package for code blocks
\usepackage{listings}
% package for coloring code
\usepackage{xcolor}
\usepackage{hyperref}
% colors for hyperlinks
\hypersetup{colorlinks=true,citecolor=black,filecolor=black,linkcolor=black,urlcolor=black}
\lstdefinelanguage{Dafny}{
  morekeywords={method, function, var, const, type, ensures, requires, modifies, assert, 
  assume, if, then, else, while, new, class, datatype, trait, extends, ghost, reads, 
  writes, lemma, forall, exists, match, case, calc, returns, decreases},
  sensitive=true,
  morecomment=[l]{//},      % Single-line comments
  morecomment=[s]{/*}{*/},  % Multi-line comments
  morestring=[b]{"}         % Strings in double quotes
}
% Define Dafny listing style
\lstdefinestyle{dafnystyle}{
  language=Dafny,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  frame=single,             % Adds a border around the code block
  breaklines=true,          % Allows line breaking
  captionpos=b              % Caption position (bottom)
}


% package for bibliography
\usepackage[authoryear,round]{natbib}
% package for header
\usepackage[automark]{scrlayer-scrpage}
\pagestyle{scrheadings}
\ihead[]{Bogdan Kyuchukov}
\ohead[]{\today}
\cfoot[]{\pagemark} 
\setheadsepline[122mm]{0.3mm}
\begin{document}
\title{
	\vspace{1cm}
	\Huge Verifying imperative programs \\ with Dafny \\
}

\vspace{1cm}

% Insert here your name and correct mail address
\author{\Large \href{mailto:B.Kyuchukov@campus.lmu.de}{Bogdan Kyuchukov}
	\vspace{1cm}}

% name of the course and module
\date{
	\large Ludwig Maximilian University of Munich \\ Course: Deductive Software Verification \\
	\vspace{0.8cm}
	\large Lecturer: Prof. Gidon Ernst\\
	\vspace{1cm}
	\today
}

\maketitle
\setlength{\parindent}{0pt}

\vspace{2cm}
\begin{abstract}
	The goal of this work is to show how to formally reason
	about imperative programming constructs such as
	assignments, loops, arrays and especially about dynamically allocated objects. To be able to achieve that, basic
	Dafny constructs will be shown, such as functions, methods, pre- and postconditions. The discussion thereafter will move
	towards recursion and termination as well as inductive datatypes. Having learned from those chapters,
	loop invariants and their usage will be explored. Because analyzing objects in the heap is more challenging,
	searching and modifying arrays will be covered. The final chapter will include a detailed discussion about Dafny's
	dynamic frames and their significance.
\end{abstract}
\newpage
\tableofcontents
\newpage

\section{Introduction} % (fold)
\label{sec:introduction}
\subsection{Why Dafny?}
When software engineers encounter the field of formal methods and verification, this usually happens
in an academic setting, where proof techniques are learned and done by hand. Moreover, actually taking advantage
of those methods in practice involves a steep learning curve and lots of time. This unfortunately leads to less
acceptance of verification techniques in
an industry where fast time to market is essential \cite{reid2020makingformalmethodsnormal}. Dafny promises to solve those problems. As a programming
language designed to support specifications and proofs, it comes with an automated verifier that integrates
seamlessly into most modern IDEs \footnote{Integrated Development Environments (IDEs)} making rigorous verification part of the software development process,
thus reducing costly late-stage bugs that may be missed by testing. The language was designed by Rustan Leino in
2009 and it's current version at the time of this writing is 4.9.0 from 31. October 2024. Dafny is heavily
used at Amazon Web Services to develop critical components of their access management, storage, and cryptography infrastructures \cite{Chakarov2022}.

\subsection{Dafny's build system}
The main idea in such verification-aware programming languages is that code is divided into two parts - the
specification part and the implementation part \cite{leino2023program}. The built-in verifier in Dafny acts as an
extended type checker and constantly proves that the provided implementation actually meets the behavior stated in
the specification part of the given function, method or class. This is done by transforming the code into an intermediary
that a tool called Boogie can understand. The correctness of the Boogie program implies the correctness of the
Dafny program. Boogie then generates first-order verification rules that are passed to the
Z3 SMT solver. Any violations of these conditions are passed back as verification errors \cite{Herbert2012}. This
process is visualized in Figure \ref{fig:build-system}.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\textwidth]{images/dafny-infra.jpg}
	\caption{The Dafny build system as shown in \cite{Herbert2012}}
	\label{fig:build-system}
\end{figure}
%weakest precondition $\mathcal{WP}$ and strongest postcondition $\mathcal{SP}$ of a program statement.
% Loop invariants
% Searching & modifying arrays
% Dynamic Frames
\section{Building Blocks of Dafny}
\label{sec:foundations}
This work assumes the reader is familiarized with the fundamentals of program-semantics such as Floyd logic and
Hoare triples, as they build the reasoning framework of Dafny and help to understand it more effectively.

\subsection{Methods}
As in other programming languages, a \textit{method} is a block of code that prescribes some behavior. For instance,
Listing \ref{lst:dafnymethod} shows the declaration of a method called \texttt{Triple}.
\begin{lstlisting}[style=dafnystyle, caption={A simple method in Dafny.}, label={lst:dafnymethod}]
method Triple(x: int) returns (r: int)
 ensures Average(x) == 3 * x {
  var y := 3 * x;
  r := x + y;
}
\end{lstlisting}
This method takes an \textit{in-parameter} x of type integer and returns an \textit{out-parameter} r, also
of type integer. The \textbf{ensures} keyword is used to specify the method's \textit{postcondition}. A postcondition expresses a property
that must hold after every invocation of the method through all possible return points.
Postconditions are part of the method's specification and appear before the body block \cite{Herbert2012}.
The body of a method is a list of statements that give the method's implementation. In Dafny,
methods can have any number of in- and out-parameters. Inside the method, the out-parameters are like local
variables and can be assigned and read. When the method ends, whatever values were assigned to the out-parameters
will be returned to the caller. The in-parameters however cannot be re-assigned \cite{leino2023program}.

\subsection{Functions}
Functions in Dafny are very mathematical in nature, because they are deterministic. Any two invocations of a
function with the same arguments will result in the same value. Listing \ref{lst:dafnyfunction} shows how a simple
function named \texttt{Average} looks like.
\begin{lstlisting}[style=dafnystyle, caption={A simple function in Dafny.}, label={lst:dafnyfunction}]
function Average(a: int, b: int): int 
 requires 0 <= a && 0 <= b {
  (a + b) / 2
}
\end{lstlisting}
Whereas a method is declared to have some number of out-parameters, a function instead declares a result type,
and while a method body is a statement, the body of a function is an expression \cite{leino2023program}.
Another important difference between functions and methods is, that functions are \textit{transparent}. This means
that their implementation is directly visible to the caller. That's the reason why functions can also be used
to describe pre- and postconditions like the precondition on line 2 in Listing \ref{lst:dafnyfunction}.
Methods on the other hand are \textit{opaque}, so callers fully rely on the postcondition to reason about their return values.
\subsection{Ghost constructs}
Sometimes when reasoning about a program more information is needed than what the compiler has at runtime.
A declaration, variable, statement, etc., that is used only for specification purposes is called a \textit{ghost}.
The verifier takes all ghosts into account, whereas the compiler erases all ghosts when it produces executable code.
Other ghost constructs include pre- and postconditions (declared by \textbf{requires} and \textbf{ensures} clauses).
They are used solely to specify the behavior of the program and establish a contract between callers and implementations \cite{leino2023program}.
\begin{lstlisting}[style=dafnystyle, caption={Invalid assignment to ghost.}, label={lst:dafnyghost}]
method InvalidAssignment() returns (y: int) {
  ghost var x := 10;
  y := 2 * x; // cannot assign to compiled variable using a ghost
}
\end{lstlisting}
To make sure ghost constructs can be successfully deleted after compilation, Dafny makes sure the compiled code
doesn't rely on any ghost constructs. Listing \ref{lst:dafnyghost} demonstrates a violation of this rule, which
results in a verification error.

\section{Recursion and termination}
A recursive function is one that calls itself directly or indirectly. To be able to terminate, all recursive
functions need a base case - a condition where the function stops calling itself and returns a result. An example
is shown with a function called \texttt{SeqSum} in Listing \ref{lst:dafnyrec}, which computes the sum of all
integers in a sequence. On line 4, if the base case isn't met, the function invokes itself with an incremented value for lo.
\begin{lstlisting}[style=dafnystyle, caption={A function computing the sum of all integers in a sequence recursively.}, label={lst:dafnyrec}]
function SeqSum(s: seq<int>, lo: int, hi: int): int
  requires 0 <= lo <= hi <= |s|
  decreases hi - lo {
  if lo == hi then 0 else s[lo] + SeqSum(s, lo + 1, hi)
}
\end{lstlisting}
\subsection{The decreases clause}
%In more complicated cases it can actually be quite challenging to find 
Dafny can prove termination by using the \textbf{decreases} clause. If we can label each function invocation with
a natural number and make sure that successive invocations strictly decrease that label, then it follows
that at run time the recursive calls can only execute a finite number of times, and that is all the information
needed to prove that the recursion eventually terminates \cite{Herbert2012}. As shown on line 3 in Listing
\ref{lst:dafnyrec}, the label of each invocation of \texttt{SeqSum} decreases gradually, because with each invocation
the difference between hi and lo is smaller. When it reaches zero, the recursion terminates.
\subsection{Well-founded relations}
Termination metrics are not restricted to natural numbers.
Termination can also be proven when two labels, which represent successive recursive invocations, are in a relation
that is \textit{well-founded} \cite{leino2023program}. This relation, denoted as $a \succ b$, signifies that a
reduces to b. For it to be \textit{well-founded}, the following three conditions must be true:
\begin{itemize}
	\item $ \succ $ is \textit{reflexive}: The relation never relates an element to itself. $a \succ a$ never holds.
	\item $ \succ $ is \textit{transitive}: Whenever $a \succ b$ and $b \succ c$ hold, then so does $a \succ c$.
	\item $ \succ $ satisfies the \textit{descending chain condition}: the relation has no \textit{infinite descending chain}.
\end{itemize}
From these conditions it follows that a well-founded relation is a strict partial order that additionally
satisfies the descending chain condition. Dafny pre-defines $ \succ $ for each type, and in some cases also
for values between different types (but in most cases, values from different types are not related in
this partial order) \cite{leino2023program}.

\section{Inductive datatypes}
\label{sec:section_about_references_within_the_document}

If you want to refer to you own chapters, figures, tables or the like, you can make use of the \texttt{ref\{\}} command, for example:
\begin{itemize}
	\item section~\ref{sec:section_about_quotations} on page \pageref{sec:section_about_quotations}
\end{itemize}



% section section_about_references_within_the_document (end)

\subsection{Subsection within Foundations} % (fold)
\label{sub:subsection_within_foundations}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
% subsection subsection_within_foundations (end)

\subsection{Another subsection within Foundations} % (fold)
\label{sub:another_subsection_within_foundations}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
% subsection another_subsection_within_foundations (end)


% section foundations (end)

\section{Methodology} % (fold)
\label{sec:methodology}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua \citep{Dix04}. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
% section methodology (end)

\section{Results} % (fold)
\label{sec:results}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua \citep[p. 48]{Baddeley:1974ts}. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
% section results (end)

\section{Conclusion} % (fold)
\label{sec:conclusion}
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
% section conclusion (end)


\newpage

\listoffigures
\lstlistoflistings
\bibliographystyle{apalike}
\bibliography{references}
\addcontentsline{toc}{section}{References}
\end{document}